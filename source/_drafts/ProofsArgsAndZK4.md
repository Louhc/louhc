---
title: ProofsArgsAndZK4
tags:
---

\newcommand{\Prv}{\mathcal{P}}
\newcommand{\Vrf}{\mathcal{V}}
\newcommand{\Lang}{\mathcal{L}}
\newcommand{\Fld}{\mathbb{F}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\Pr}{\text{Pr}}
\newcommand{\out}{\text{out}}
\newcommand{\deg}{\text{deg}}
\newcommand{\poly}{\text{poly}}

本篇笔记涵盖 [《Proofs, Arguments, and Zero-Knowledge》](https://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.pdf) 的**第11章**和**第12章**。

<!-- more -->

## 11 零知识证明和论证

### What is Zero-Knowledge

> (Informal definition of zero-knowledge). A proof or argument system with prescribed prover $\Prv$ and prescribed verifier $\Vrf$ for a language $\Lang$ is said to be zero-knowledge if for any probabilistic polynomial time verifier strategy $\hat{\Vrf}$, there exists a probabilistic polynomial time algorithm $S$ (which can depend on $\hat{\Vrf}$), called the simulator, such that for all $x\in\Lang$, the distribution of the output $S(x)$ of the simulator is “indistinguishable” from $\text{View}_{\hat{\Vrf}}(\Prv(x),\hat{\Vrf}(x))$. Here, $\text{View}_{\hat{\Vrf}}(\Prv(x),\hat{\Vrf}(x))$ denotes the distribution over transcripts generated by the interaction of prover strategy $\Prv$ and verifier strategy $\hat{\Vrf}$ within the proof or argument system.

主要针对 prover，也就是说就算换一个 verifier 来，无论怎么做都无法从 prover 那里套出其他的信息。

- perfect zero knowledge: $S(x)$ 和 $\text{View}$ 产生的分布**完全**一样。
- statistical zero knowledge: 两者产生的分布只有可忽略的 "statistical distance"，即 $$\frac12\sum_{y}|\Pr[D_1(x)=y]-\Pr[D_2(x)=y]|$$ 它等价于 $$\max_{\A}|\underset{y\leftarrow D_1}{\Pr}[\A(y)=1]-\underset{y\leftarrow D_2}{\Pr}[\A(y)=1]|$$
- computational zero-knowledge: 对于多项式时间算法 $\mathcal A$ 无法区分两个分布。

statiscial zero knowledge 比较弱，尽管人们相信它能解决一些 BPP(Bounded-error Probalistic Polynomial-time) 以外的问题，但是并不认为它能解决 NPC 问题。（突然有个疑问，如果问题 $A$ 能归约到问题 $B$，那么存在 $B$ 的零知识证明能推出存在 $A$ 的零知识证明吗？好像从来没有仔细思考过这个问题，也没在哪里看到过，也许书上有但我漏了？）

需要注意，一个诚实的 $\Vrf$ 的 view 和 simulator $S(x)$ 无法区分，并不代表着这个问题是 **NP** 问题，这要求对于 $x\in\Lang,x'\notin\Lang$，$S(x)$ 和 $S'(x)$ 无法区分。$\Prv$ 可能知道关于陈述的证据 $w$，$S$ 可以在不知道 $w$ 的情况下生成一个 accepting transcipt。

$S$ 可以为 $x\notin\Lang$ 生成一个 accepting transcript，但是这并不违背 soundness，即使一个恶意的 prover 知道 $x\notin\Lang$ 的 accepting transcript 分布，它也无法说服 verifier，因为证明的过程是**交互**的。（我有个想法，满足 zero-knowledge 是否意味着，通过 prover 的回复能高效地推导出 verifier 的 challenge，反过来却不行？）

statistical zero-knowledge proof with a polynomial time verifier 能处理的语言在复杂度集 $\mathbf{AM}\cap\mathbf{coAM}$ 中。其中 $\mathbf{AM}$ 指的是 Solvable in polynomial time by an Arthur–Merlin protocol，$\mathbf{coAM}$ 指的是 $\{L\,|\,\overline{L}\in\mathbf{AM}\}$，前面提到过，一般认为 $\mathbf{AM}$ 是等价于 $\mathbf{NP}$ 的。

## 12 Σ-Protocols and Commitments from Hardness of Discrete Logarithm

关于离散对数问题和椭圆曲线群的基础知识见[**这里**](/2024/06/30/modern-crypto-9/)

### Schnorr’s Σ-Protocol for Knowledge of Discrete Logarithms

关系 $\mathcal R$ 指定了一组“有效”的实例-证据对 $(h,w)$。一个关于 $\mathcal R$ 的 $\Sigma$-protocol 是一个 **3-message public coin protocol**，其中证明者和验证者知道一个共同的输入实例 $h$，证明者知道一个证据 $w$ 使得 $(h,w)\in\mathcal R$。

将他们之间的三次消息表示为 $(a,e,z)$，证明者先发送 $a$，验证者发送 challenge $e$（由于 public coin，他使用的随机数具体值都会被证明者立即知道），证明者回复 $z$。

$\Sigma$-protocol 要求满足 **perfect completeness**，即如果证明者按照协议正确回答，验证者会以概率 $1$ 接受（注意概率 $1$ 不等于一定）。除此之外，$\Sigma$-protocol 还要求满足其他两条性质。

**Special soundness**，要求存在一个多项式时间算法 $\mathcal Q$，使得对于任意两对 accepting transcript，$(a,e,z),(a,e',z')$，其中 $e\neq e'$，$\mathcal Q$ 都能找到一个 $w$ 使得 $(h,w)\in\mathcal R$。它保证如果 $\mathcal P$ 知道多于一个 challenge 的答案，那么他就必定知道证据 $w$。

**Honest Verifier Perfect Zero-Knowledge**，要求存在一个随机多项式时间模拟器 $S$，输入 $h$，能输出和 $\Sigma$-protocol 中**完全一样**的transcript 分布（诚实的证明者和验证者）。

（skip）

## 13 Zero-Knowledge via Commit-And-Prove and Masking Polynomials

尽管已经有人构造了 3-color 问题（$\in\mathbf{NPC}$），且可以通过它构造出任意 $\mathbf{NP}$ 问题，但是直接通过这样的方式构造效率会很低。

这一章主要介绍了如何通过 Commit-And-Prove 来构造关于 Circuit SAT 的 ZK argument。

在 Pedersen commitment 中，设 $c_1$ 和 $c_2$ 的 commitment 为 $m_1,m_2$，那么 (1) 可以在多项式时间直接通过 $m_1,m_2$ 计算 $c_1+c_2$ 的 commitment；(2) 对于 $c_3=c_1\cdot c_2$ 的 commitment $m_3$，存在一个 $\Sigma$-protocol，证实 $m_3$ 是 $c_3$ 的 commitment。

设 $\mathcal C$ 是一个素阶域 $\Fld$ 上的算数电路，$\mathcal G$ 是与 $\Fld$ 同阶的循环群，且离散对数问题在 $\mathcal G$ 上是困难的。假设 $\mathcal C$ 中的乘法门都只有两个输入。假设证明者想证明他知道一个 $w$ 使得 $\mathcal C(w)=1$。

在协议的开始，证明者向验证者发送 $w$ 中每一项的 commitment，以及每个乘法门输出的 commitment。然后，对于每个乘法门的输出的 commitment，证明者都要向验证者证实。证明者打开最终得到的 commitment，如果确实为 $1$，验证者接受。

（skip）