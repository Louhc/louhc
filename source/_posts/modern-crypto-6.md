---
title: Introduction to Modern Cryptography(6)
author: louhc
categories: Reading Notes
date: 2024/6/27 13:00:00
tags:
 - crypto
keywords: 
description:
mathjax: true
---

\usepackage{amsmath,amssymb,amsthm}

\newcommand{\Enc}{\text{Enc}}
\newcommand{\Dec}{\text{Dec}}
\newcommand{\Gen}{\text{Gen}}
\newcommand{\Vrfy}{\text{Vrfy}}
\newcommand{\Mac}{\text{Mac}}
\newcommand{\K}{\mathcal{K}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\Adv}{\mathcal{A}}
\newcommand{\Qry}{\mathcal{Q}}
\newcommand{\Hsh}{\mathcal{H}}
\newcommand{\Pr}{\text{Pr}}
\newcommand{\negl}{\text{negl}}
\newcommand{\poly}{\text{poly}}
\newcommand{\Func}{\text{Func}}
\newcommand{\Perm}{\text{Perm}}
\newcommand{\PrivK}{\text{PrivK}}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{protocol}{Protocol}

# *Introduction to Modern Cryptography* Reading Notes

## 6 Hash Functions and Applications

### 哈希函数的定义

> A hash function (with output length $\ell(n)$) is a pair of probabilistic polynomial-time algorithms $(\Gen, H)$ satisfying the following:
> 
> - $\Gen$ is a probabilistic algorithm that takes as input a security parameter $1^n$ and outputs a key $s$. We assume that $n$ is implicit in $s$.
> - $H$ is a deterministic algorithm that takes as input a key $s$ and a string $x \in \{0, 1\}^∗$ and outputs a string $H^s(x) \in \{0, 1\}^{\ell(n)}$ (where $n$ is the value of the security parameter implicit in $s$).
>
> If $H^s$ is defined only for inputs $x$ of length $\ell'(n) > \ell(n)$, then we say that $(\Gen, H)$ is a fixed-length hash function for inputs of length $\ell'(n)$. In this case, we also call $H$ a *compression function*.

在这里，攻击者往往会知道 $s$ 的值，因此 $s$ 放在 $H$ 的上标。

> The collision-finding experiment $\text{Hash-coll}_{\Adv,\Hsh(n)}$ $(\Hsh=(\Gen,H))$:
> 
> 1. A key $s$ is generated by running $\Gen(1^n)$.
> 2. The adversary $\Adv$ is given $s$, and outputs $x, x'$ . (If $H$ is a fixed-length hash function for inputs of length $\ell'(n)$, then we require $x, x' \in \{0, 1\}^{\ell'(n)}$.)
> 3. The output of the experiment is defined to be $1$ if and only if $x = x'$ and $H^s(x) = H^s(x')$. In such a case we say that $\Adv$ has found a collision.

如果 $\Pr[\text{Hash-coll}_{\Adv,\Hsh(n)}=1]\leq\negl(n)$，则称 $\Hsh$ 是**collision resistant**的。

下面给出两个其他关于哈希安全的概念。

- **Second-preimage resistance** 给出 $s$ 和一个均匀分布的 $x$，一个PPT的 $\Adv$ 几乎无法找到 $x'$ 使得 $x\neq x',H(x)=H(x')$
- **Preimage resistance**  给出 $s$ 和 $y=H^s(x)$ 对于一个均匀分布的 $x$，一个PPT的 $\Adv$ 几乎无法找到 $x'$ 使得 $H(x)=H(x')$ ($x'$ 可以等于 $x$)

---

### Merkle–Damgård 变换

**Merkle–Damgård 变换**可以将一个固定长度的哈希函数，用于任意长度的输入。

> Let $(\Gen, h)$ be a compression function for inputs of length $n + n' \geq 2n$ with output length $n$. Fix $\ell \leq n'$ and $IV \in \{0, 1\}^n$. Construct hash function $(\Gen, H)$ as follows:
> 
> - $\Gen$: remains unchanged.
> - $H$: on input a key $s$ and a string $x \in \{0, 1\}^∗$ of length $L < 2^{\ell}$ , do:
> 
>    1. Append a $1$ to $x$, followed by enough zeros so that the length of the resulting string is $\ell$ less than a multiple of $n'$. Then append $L$, encoded as an $\ell$-bit string. Parse the resulting string as the sequence of $n'$-bit blocks $x_1,...,x_B$.
>    2. Set $z_0 := IV$.
>    3. For $i=1,...,B$, compute $z_i := h^s(z_{i−1}|| x_i)$.
>    4. Output $z_B$.

可以证明，如果 $(\Gen,h)$ 是 collision resistent 的，那么 $(\Gen,H)$ 也是。（证明先跳过）

---

### 使用哈希函数的消息认证

---

### 对哈希函数的一般攻击

---

### The Random-Oracle Model

random-oracle model 将哈希函数视为一个随机函数，假设存在一个随机函数 $H$，只能通过黑盒访问 $H$ 获取 $H(x)$ 的值。

注意，random-oracle model 不是伪随机函数，因为伪随机函数只有在 key 保密时是伪随机的，但是所有群体都能计算 random-oracle model，不可能有一个保密的 key。

> If $x$ has not been queried to $H$, then the value of $H(x)$ is **uniform**.

> If $\Adv$ queries $x$ to $H$, the reduction can see this query and learn $x$.

> The reduction can set the value of $H(x)$ (i.e., the response to query $x$) to a value of its choice, as long as this value is correctly distributed, i.e., uniform.