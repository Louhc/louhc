---
title: Proofs, Arguments, and Zero-Knowledge (4)
date: 2025-08-24 13:22:24
author: louhc
categories: Reading Notes
tags:
 - crypto
 - zk
 - PAZK
keywords: 
description:
mathjax: true
---


\newcommand{\Prv}{\mathcal{P}}
\newcommand{\Vrf}{\mathcal{V}}
\newcommand{\Lang}{\mathcal{L}}
\newcommand{\Fld}{\mathbb{F}}
\newcommand{\A}{\mathcal{A}}
\newcommand{\Pr}{\text{Pr}}
\newcommand{\out}{\text{out}}
\newcommand{\deg}{\text{deg}}
\newcommand{\poly}{\text{poly}}

本篇笔记涵盖 [《Proofs, Arguments, and Zero-Knowledge》](https://people.cs.georgetown.edu/jthaler/ProofsArgsAndZK.pdf) 的**第11章**，**第12章**和**第13章**。

<!-- more -->

## 11 零知识证明和论证

### What is Zero-Knowledge

> (Informal definition of zero-knowledge). A proof or argument system with prescribed prover $\Prv$ and prescribed verifier $\Vrf$ for a language $\Lang$ is said to be zero-knowledge if for any probabilistic polynomial time verifier strategy $\hat{\Vrf}$, there exists a probabilistic polynomial time algorithm $S$ (which can depend on $\hat{\Vrf}$), called the simulator, such that for all $x\in\Lang$, the distribution of the output $S(x)$ of the simulator is “indistinguishable” from $\text{View}_{\hat{\Vrf}}(\Prv(x),\hat{\Vrf}(x))$. Here, $\text{View}_{\hat{\Vrf}}(\Prv(x),\hat{\Vrf}(x))$ denotes the distribution over transcripts generated by the interaction of prover strategy $\Prv$ and verifier strategy $\hat{\Vrf}$ within the proof or argument system.

- perfect zero-knowledge: $S(x)$ 和 $\text{View}$ 产生的分布**完全**一样。
- statistical zero-knowledge: 两者产生的分布只有可忽略的 "statistical distance"，即 $$\frac12\sum_{y}|\Pr[D_1(x)=y]-\Pr[D_2(x)=y]|$$ 它等价于 $$\max_{\A}|\underset{y\leftarrow D_1}{\Pr}[\A(y)=1]-\underset{y\leftarrow D_2}{\Pr}[\A(y)=1]|$$
- computational zero-knowledge: 对于多项式时间算法 $\mathcal A$ 无法区分两个分布。

statiscial zero-knowledge 比较弱，尽管人们相信它能解决一些 $\mathbf{BPP}$(Bounded-error Probalistic Polynomial-time) 以外的问题，但是并不认为它能解决 NPC 问题。（突然有个疑问，如果问题 $A$ 能归约到问题 $B$，那么存在 $B$ 的零知识证明能推出存在 $A$ 的零知识证明吗？好像从来没有仔细思考过这个问题，也没在哪里看到过，也许书上有但我漏了？）

需要注意，一个诚实验证者的视图（view）和模拟器 $S(x)$ 无法区分，并不代表着这个问题可以被高效计算。原因在于其要求对于任意一对 $(x,x'),x\in\Lang,x'\notin\Lang$，$S(x)$ 和 $S'(x)$ 可以被高效区分，这一点并没有包含在 Zero-Knowledge 的定义中。事实上，$S$ 在 $x'\notin\Lang$ 上的取值并在Zero-Knowledge中没有任何定义。甚至 $S$ 可以在不知道 $w$ 的情况下生成一个接受的会话记录（accepting transcript）。

$S$ 可以为 $x\notin\Lang$ 生成一个接受的会话记录，但是这并不违背 soundness，即使一个恶意的证明者知道 $x\notin\Lang$ 的接受会话记录的分布，它也无法说服验证者，因为证明的过程是**交互**的。（疑问：满足 zero-knowledge 是否意味着，通过 prover 的回复能高效地推导出 verifier 的 challenge，反过来却不行？）

### The Limits of Statistical Zero Knowledge Proofs

statistical zero-knowledge proof with a polynomial time verifier 能处理的语言在复杂度集 $\mathbf{AM}\cap\mathbf{coAM}$ 中。其中 $\mathbf{AM}$ 指的是 Solvable in polynomial time by an Arthur–Merlin protocol，$\mathbf{coAM}$ 指的是 $\{L\,|\,\overline{L}\in\mathbf{AM}\}$。一般认为 $\mathbf{AM}$ 是等价于 $\mathbf{NP}$ 的。

而这本书中的 SNARK 能解决 $\mathbf{NEXP}$ 中的问题，因此 statistical zero-knowledge proof 是不够强的。

### Honest-Verifier SZK Protocol for Graph Non-Isomorphism

> **协议**
> 
> - 验证者随机选取 $b\in\{1,2\}$，然后随机选取一个随机排列 $\pi:\{1,...,n\}\to\{1,...,n\}$。
> - 验证者把 $\pi(G_b)$ 发给证明者。
> - 证明者回复 $b'$。
> - 如果 $b=b'$，验证者输出 $\mathsf{accept}$，否则输出 $\mathsf{reject}$。

### Honest-Verifier SZK Protocol for the Collision Problem

对于列表 $(x_1,...,x_N)$，$x_i$ 的取值范围的大小为 $R$，且 $N=R$。我们希望判断是否所有的 $x_i$ 都各不相同。

假设要么所有的 $x_i$ 都不相同，要么恰好 $R/2$ 个元素各出现了 $2$ 次。

我们希望验证者的时间是 $\mathsf{polylog}(N)$ 的。

> **协议**
> 
> - 验证者随机选取一个 $k\in[R]$ 并发给证明者。
> - 证明者将 $k$ 的原象 $x$ 发给验证者。
> - 如果 $f(x)=k$，验证者输出 $\mathsf{accecpt}$，否则输出 $\mathsf{reject}$。

## 12 Σ-Protocols and Commitments from Hardness of Discrete Logarithm

关于离散对数问题和椭圆曲线群的基础知识见[**这里**](/2024/06/30/modern-crypto-9/)

### Schnorr’s Σ-Protocol for Knowledge of Discrete Logarithms

关系 $\mathcal R$ 指定了一组“有效”的实例-证据对 $(h,w)$。一个关于 $\mathcal R$ 的 $\Sigma$-protocol 是一个 **3-message public coin protocol**，其中证明者和验证者知道一个共同的输入实例 $h$，证明者知道一个证据 $w$ 使得 $(h,w)\in\mathcal R$。

将他们之间的三次消息表示为 $(a,e,z)$，证明者先发送 $a$，验证者发送 challenge $e$（由于 public coin，他使用的随机数具体值都会被证明者立即知道），证明者回复 $z$。

$\Sigma$-protocol 要求满足 **perfect completeness**，即如果证明者按照协议正确回答，验证者会以概率 $1$ 接受（注意概率 $1$ 不等于一定）。除此之外，$\Sigma$-protocol 还要求满足其他两条性质。

**Special soundness**，要求存在一个多项式时间算法 $\mathcal Q$，使得对于任意两对 accepting transcript，$(a,e,z),(a,e',z')$，其中 $e\neq e'$，$\mathcal Q$ 都能找到一个 $w$ 使得 $(h,w)\in\mathcal R$。它保证如果 $\mathcal P$ 知道多于一个 challenge 的答案，那么他就必定知道证据 $w$。

**Honest Verifier Perfect Zero-Knowledge**，要求存在一个随机多项式时间模拟器 $S$，输入 $h$，能输出和 $\Sigma$-protocol 中**完全一样**的transcript 分布（诚实的证明者和验证者）。

（skip）

## 13 Zero-Knowledge via Commit-And-Prove and Masking Polynomials

尽管已经有人构造了 3-color 问题（$\in\mathbf{NPC}$）的 zk-argument，且可以通过它构造出任意 $\mathbf{NP}$ 问题的 zk-argument，但是直接通过这样的方式构造效率会很低。

这一章主要介绍了如何通过 Commit-And-Prove 来构造关于 Circuit-SAT 的 zk-argument。

对于电路 $\mathcal C$，证明者想证明他知道一个 $w$ 使得 $\mathcal C(w)=1$。考虑下面的一个原始的协议。

在协议的开始，证明者向验证者发送 $w$，以及每个门的扇出。验证者检查每个门都被正确计算，并且输出门的值是 $1$，如果通过检查，输出 $\mathsf{accept}$，否则输出 $\mathsf{reject}$。这个协议是信息论可靠的，但不是零知识的。

为了实现零知识，证明者不直接发送 $w$ 和每个门的输出，而是发送它们的承诺，最终验证者打开输出门的承诺。

### Proof Length of Witness Size Plus Multiplicative Complexity

在 Pedersen commitment 中，设 $c_1$ 和 $c_2$ 的承诺为 $m_1,m_2$，那么 (1) 可以在多项式时间直接通过 $m_1,m_2$ 计算 $c_1+c_2$ 的承诺；(2) 对于 $c_3=c_1\cdot c_2$ 的承诺 $m_3$，存在一个 $\Sigma$-protocol，证实 $m_3$ 是 $c_3$ 的承诺。

我们可以通过其构建接下来的 zk-argument。令 $\mathcal C$ 为定义在素阶域 $\mathbb F$ 上的算术电路，$\mathbb G$ 是一个与 $\mathcal F$ 同阶的循环群，假设在 $\mathbb G$ 上 DLP 问题是困难的。假设所有乘法门只有两个扇入（加法门可以有无限多个扇入，我们可以假设加法门的扇入都是乘法门的扇出）。证明者知道一个 $w$ 使得 $\mathcal C(w)=1$。

在协议的开始，证明者发送 $w$ 每个元素以及所有乘法门扇出的 Pedersen commitment。